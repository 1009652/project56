/* -*- c++ -*- */
/*
 * Copyright 2004,2010 Free Software Foundation, Inc.
 *
 * This file is part of GNU Radio
 *
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 3, or (at your option)
 * any later version.
 *
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif

#include <ais_nmea_decoder.h>
#include <gr_io_signature.h>
#include <iostream>
#define DBG(x) x

/*
 * Create a new instance of ais_nmea_decoder and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */
ais_nmea_decoder_sptr
ais_make_nmea_decoder (const char *host,const char *database, const char *user, const char *password)
{
  return gnuradio::get_initial_sptr(new ais_nmea_decoder (host,database,user,password));
}

/*
 * Specify constraints on number of input and output streams.
 * This info is used to construct the input and output signatures
 * (2nd & 3rd args to gr_block's constructor).  The input and
 * output signatures are used by the runtime system to
 * check that a valid number and type of inputs and outputs
 * are connected to this block.  In this case, we accept
 * only 1 input and 1 output.
 */
static const int MIN_IN = 1;	// mininum number of input streams
static const int MAX_IN = 1;	// maximum number of input streams
static const int MIN_OUT = 0;	// minimum number of output streams
static const int MAX_OUT = 0;	// maximum number of output streams

/*
 * The private constructor
 */
ais_nmea_decoder::ais_nmea_decoder (const char *host,const char *database, const char *user, const char *password)
  : gr_block ("nmea_decoder",
		   gr_make_io_signature (MIN_IN, MAX_IN, 200),
		   gr_make_io_signature (MIN_OUT, MAX_OUT, sizeof (float)))
{
  // nothing else required in this example
#ifdef HAVE_MYSQL
	if(!mysql_init(&d_conn))
	{
		throw std::runtime_error("Couldn't initialize mysql\n");
	}
	if (!mysql_real_connect(&d_conn,host,user,password, database, 0, NULL, 0))
	{
		throw std::runtime_error("Couldn't connect to mysql server\n");
	}
#endif
}

/*
 * Our virtual destructor.
 */
ais_nmea_decoder::~ais_nmea_decoder ()
{
#ifdef HAVE_MYSQL
	mysql_close(&d_conn);
#endif
}

void ais_nmea_decoder::get_data (int bufferlengde)    // Picks out interesting data from the bits and sends to MySQL-database 
{
	std::ostringstream sqlquery;
//	printf("__________\n");
	unsigned char type = henten(0,6,d_rbuffer);
	for(int i=0;i<200;i++) {
		printf("%d",d_rbuffer[i]);
	}
	printf("\n");
	//printf("MessageID: %d\n",type);
	unsigned long mmsi = henten(8,30,d_rbuffer);
	//printf("MMSI: %09d\n",mmsi);
	unsigned long day,hour, minute, second,year,month;
	int longitude,latitude;
	unsigned short course, heading, sog;
	char name[21];
	char destination[21];
	char rateofturn, underway;
	unsigned int A,B;
	unsigned char C,D;
	unsigned char height;
	//for(int m=0;m<bufferlengde;m++)
	//{
	//	d_tbuffer[m] = d_rbuffer[m] + 0x30;
	//}
	//d_tbuffer[bufferlengde] = 0;

	//time_t tid;
	int k, hvor, letter;
#ifdef HAVE_MYSQL
	MYSQL_RES *res;
#endif
	//int tid = 0;
	time_t tid;
	time(&tid);
switch(type){
    case 1:
    case 2:
    case 3:
	    longitude = henten(61,28,d_rbuffer);
		if(((longitude >> 27)&1)==1)
		longitude |= 0xF0000000;
	    latitude = henten(38+22+29,27,d_rbuffer);
	    if(((latitude >> 26)&1)==1)
		    latitude |= 0xf8000000;
	    course = henten(38+22+28+28,12,d_rbuffer);
	    sog = henten(50,10,d_rbuffer);
	    rateofturn = henten(38+2,8,d_rbuffer);
	    underway = henten(38,2,d_rbuffer);
	    heading = henten(38+22+28+28+12,9,d_rbuffer);

	   DBG(printf("%d:  %09d %10f %10f %5f %5f %5i %5d %5d\n",(int)type,(int)mmsi,(float)latitude/600000,(float)longitude/600000,(float)course/10,(float)sog/10,(int)rateofturn,(int)underway,(int)heading);)
		
	sqlquery << "insert into ais_position (time,mmsi,latitude,longitude,heading,course,speed) values (now(),"<<mmsi<<","<< std::setprecision(9) << (float)latitude/600000 << "," << std::setprecision(9) <<  (float)longitude/600000 << "," << std::setprecision(7) << (float)heading << ","<<(float)course/10<<"," << (float)sog/10 << ")";

       break;
    case 4:
	    year = henten(40,12,d_rbuffer);
	    month = henten(52,4,d_rbuffer);
	    day = henten(56,5,d_rbuffer);
	    hour = henten(61,5,d_rbuffer);
	    minute = henten(66,6,d_rbuffer);
	    second = henten(72,6,d_rbuffer);
	    longitude = henten(79,28,d_rbuffer);
		if(((longitude >> 27)&1)==1)
		longitude |= 0xF0000000;
	    latitude = henten(107,27,d_rbuffer);
	    if(((latitude >> 26)&1)==1)
		    latitude |= 0xf8000000;

    DBG(printf("%d:  %09d %d %d %d %d %d %d %f %f\n",(int)type,(int)mmsi,(int)year,(int)month,(int)day,(int)hour,(int)minute,(int)second,(float)latitude/600000,(float)longitude/600000);)

	sqlquery << "insert into ais_basestation (time,mmsi,longitude,latitude) values (now()," << mmsi << ","<<std::setprecision(9)<<(float)longitude/600000<< ","<<std::setprecision(9)<<(float)latitude/600000<<")";

    	break;
    case 5:
	hvor = 112;
	for(k=0;k<20;k++)
	{
		letter = henten(hvor,6,d_rbuffer);
		bokstavtabell(letter,name,k);
		hvor += 6;
	}
	name[20] = 0;
//	printf("Name: %s\n", name);
	hvor = 120+106+68+8;
	for(k=0;k<20;k++)
	{
		letter = henten(hvor,6,d_rbuffer);
		bokstavtabell(letter,destination,k);
		hvor += 6;
	}
	destination[20] = 0;
//	printf("Destination: %s\n",destination);
	A = henten(240,9,d_rbuffer);
	B = henten(240+9,9,d_rbuffer);
	C = henten(240+9+9,6,d_rbuffer);
	D = henten(240+9+9+6,6,d_rbuffer);
	height = henten(294,8,d_rbuffer);
//	printf("Length: %d\nWidth: %d\nHeight: %f\n",A+B,C+D,(float)height/10);
	DBG(printf("%d:  %09d %s %s %d %d %f\n",type,mmsi,name,destination,A+B,C+D,(float)height/10);)

	sqlquery << "insert into ais_vesseldata (time,mmsi,name,destination,draught,A,B,C,D) values (now(),"<<mmsi<<",\""<<name<<"\",\""<<destination<<"\","<<(float)height/10<<","<<(int)A<<","<<(int)B<<","<<(int)C<<","<<(int)D<<")";


	break;
    default:
	return;
	break;

}
	//std::cout << sqlquery.str() << "\n";
#ifdef HAVE_MYSQL
	if (mysql_query(&d_conn, sqlquery.str().c_str()))
	{
		throw std::runtime_error("Couldn't do query\n");
	}	
	res = mysql_use_result(&d_conn);
	mysql_free_result(res);
#endif
}

unsigned long ais_nmea_decoder::henten(int from, int size, unsigned char *frame)
{
	int i=0;
	unsigned long tmp = 0;
	for(i=0;i<size;i++)
	{
		tmp |= (frame[from+i]) << (size-1-i);
	}
	return tmp;

}

void ais_nmea_decoder::bokstavtabell(char sixbit, char* name, int pos)
{
    if (sixbit >= 1 && sixbit <= 31) {
        name[pos] = sixbit + 64;
        return;
    }    
    
    if (sixbit >= 32 && sixbit <= 63) {
        name[pos] = sixbit;
        return;
    }    
    
    name[pos] = ' ';
}

void ais_nmea_decoder::nmea_decode(char *nmea)
{
	int i,j,commas;
	char aispart[200];
	commas = 0;
	char bokstav;
	std::cout << nmea << "\n";
	DBG(printf("nmealength %d\n", strlen(nmea) * 6));
	for (j=0;j<100;j++) {
		if(nmea[j] == ',') {
			commas++;
		}
		if(commas == 5) {
			break;
		}
	}
	memcpy(aispart,nmea+j+1,strlen(nmea)-j-1);
	//if(commas != 5) return;
	
	for (i = 0; i < ((strlen(aispart)) * 6); i++) {

		bokstav = (aispart[(i / 6)]);

		if (bokstav == ',')
			break;
		if (bokstav <= 87)
			bokstav = bokstav - 48;
		else
			bokstav = bokstav - 56;
		d_rbuffer[i] = (bokstav >> (5 - (i % 6))) & 0x01;
	}

}


int
ais_nmea_decoder::general_work (int noutput_items,
			gr_vector_int &ninput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  const char *in = (const char *) input_items[0];
	char tmp[200];
#ifdef HAVE_MYSQL
	MYSQL_RES *res;
#endif
	std::ostringstream sqlquery;
	size_t block_size = output_signature()->sizeof_stream_item(0);
  for (int i = 0; i < ninput_items[0]; i++){
		memcpy(tmp,in,200);
		nmea_decode(tmp);

#ifdef HAVE_MYSQL
		sqlquery << "insert into ais_nmea (time,message) values (now(),'"<< tmp << "')";
		if (mysql_query(&d_conn, sqlquery.str().c_str()))
		{
			throw std::runtime_error("Couldn't do query\n");
		}	
		res = mysql_use_result(&d_conn);
		mysql_free_result(res);
#endif

		get_data(200);
		in = in + block_size;
	}
  //for (int i = 0; i < noutput_items; i++){
  //  out[i] = in[i] * in[i];
  //}
  consume_each (ninput_items[0]);
  // Tell runtime system how many output items we produced.
  return 0; 
}
