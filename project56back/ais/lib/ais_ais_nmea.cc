/* -*- c++ -*- */
/*
 * Copyright 2004 Free Software Foundation, Inc.
 * 
 * This file is part of GNU Radio
 * 
 * GNU Radio is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2, or (at your option)
 * any later version.
 * 
 * GNU Radio is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with GNU Radio; see the file COPYING.  If not, write to
 * the Free Software Foundation, Inc., 51 Franklin Street,
 * Boston, MA 02110-1301, USA.
 */

/*
 * config.h is generated by configure.  It contains the results
 * of probing for features, options etc.  It should be the first
 * file included in your .cc file.
 */
#ifdef HAVE_CONFIG_H
#include "config.h"
#endif
#define DBG(x) x
#include <ais_ais_nmea.h>
#include <gr_io_signature.h>

#define NMEA_LENGTH 200
/*
 *
 * Create a new instance of ais_ais_nmea and return
 * a boost shared_ptr.  This is effectively the public constructor.
 */


ais_ais_nmea_sptr 
ais_make_ais_nmea ()			// This is needed for python to access this class
{
  return ais_ais_nmea_sptr (new ais_ais_nmea ());
}


/*
 * The private constructor
 */
ais_ais_nmea::ais_ais_nmea ()
  : gr_block ("ais_nmea",
		   gr_make_io_signature (1,1, sizeof(char)),	// Number of minimum input ports, maximum output ports and size of each element (char = 1byte)
		   gr_make_io_signature (0,1,NMEA_LENGTH))
		 		// Initializing class members   d_x for horizontal position and d_y for vertical position
{
//	set_output_multiple(8);
	d_receivedframes = 0;
	d_lostframes = 0;
	d_lostframes2 = 0;
	restart();
}


unsigned short ais_ais_nmea::sdlc_crc(unsigned char *data, unsigned len) // Calculates CRC-checksum
{
	unsigned short c, crc=0xffff;

	while(len--)
		for(c = 0x100 + *data++; c> 1 ; c >>=1)
			if((crc ^ c) & 1)
				crc=(crc>>1)^0x8408;
			else
				crc>>=1;
	return ~crc;

}

bool ais_ais_nmea::calculate_crc(int lengde)          
{
	int antallbytes = lengde / 8;
	unsigned char *data = (unsigned char*) malloc(sizeof(unsigned char)*(antallbytes+2));
	if (data == NULL)
	{
		throw std::runtime_error("Error allocating memory\n");
	}
	int i,j;

	unsigned char tmp;

	for(j=0;j<antallbytes + 2;j++)
	{
		tmp = 0;
		for(i=0;i<8;i++)
			tmp |= (((d_buffer[i+8*j]) << (i)));
		data[j] = tmp;
	}
	unsigned short crc = sdlc_crc(data,antallbytes+2);
	DBG(printf("CRC: %04x\n",crc);)
	memset(d_rbuffer,0,250*sizeof(char));
	for(j=0;j<antallbytes;j++)
	{
		for(i=0;i<8;i++)
			d_rbuffer[j*8+i] = (data[j] >> (7-i)) &1;
	}
	free(data);
	return (crc == 0x0f47);
}

unsigned long ais_ais_nmea::henten(int from, int size, unsigned char *frame)
{
	int i=0;
	unsigned long tmp = 0;
	for(i=0;i<size;i++)
	{
		tmp |= (frame[from+i]) << (size-1-i);
	}
	return tmp;

}

int ais_ais_nmea::protodec_generate_nmea(char *nmea, int bufferlen, int fillbits)
{
	int senlen;
	int pos;
	int k, letter;
	int m;
	unsigned char sentences, sentencenum, nmeachk;
	char nchk[3];
	int serbuffer_l;
	memset(nmea,0,NMEA_LENGTH);
	
	//6bits to nmea-ascii. One sentence len max 82char
	//inc. head + tail.This makes inside datamax 62char multipart, 62 single
	senlen = 199;		//this is normally not needed.For testing only. May be fixed number
	if (bufferlen <= (senlen * 6)) {
		sentences = 1;
	} else {
		sentences = bufferlen / (senlen * 6);
		//sentences , if overflow put one more
		if (bufferlen % (senlen * 6) != 0)
			sentences++;
	};
	DBG(printf("NMEA: %d sentences with max data of %d ascii chrs\n", sentences, senlen));
	sentencenum = 0;
	pos = 0;
	do {
		k = 13;		//leave room for nmea header
		while (k < senlen + 13 && bufferlen > pos) {
			letter = henten(pos, 6, d_rbuffer);
			// 6bit-to-ascii conversion by IEC
			if (letter < 40)
				letter = letter + 48;
			else
				letter = letter + 56;
			nmea[k] = letter;
			pos += 6;
			k++;
		}
		DBG(printf("NMEA: Drop from loop with k:%d pos:%d senlen:%d bufferlen:%d\n",
			k, pos, senlen, bufferlen));
		//set nmea trailer with 00 checksum (calculate later)
		nmea[k] = 44;
		nmea[k + 1] = 48;
		nmea[k + 2] = 42;
		nmea[k + 3] = 48;
		nmea[k + 4] = 48;
		nmea[k + 5] = 0;
		sentencenum++;
		
		// printout one frame starts here
		//AIVDM,x,x,,, - header comes here first
		
		nmea[0] = 65;
		nmea[1] = 73;
		nmea[2] = 86;
		nmea[3] = 68;
		nmea[4] = 77;
		nmea[5] = 44;
		nmea[6] = 48 + sentences;
		nmea[7] = 44;
		nmea[8] = 48 + sentencenum;
		nmea[9] = 44;
		
		//if multipart message it needs sequential id number
		if (sentences > 1) {
			DBG(printf("NMEA: It is multipart (%d/%d), add sequence number (%d) to header\n",
				sentences, sentencenum, d_seqnr));
			nmea[10] = d_seqnr + 48;
			nmea[11] = 44;
			nmea[12] = 44;
			//and if the last of multipart we need to show fillbits at trailer
			if (sentencenum == sentences) {
				DBG(printf("NMEA: It is last of multipart (%d/%d), add fillbits (%d) to trailer\n",
					sentences, sentencenum, fillbits));
				nmea[k + 1] = 48 + fillbits;
			}
		} else {	//else put channel A & no seqnr to keep equal lenght (foo!)
			nmea[10] = 44;
			nmea[11] = 65;
			nmea[12] = 44;
		}

		//strcpy(nmea,"!AIVDM,1,1,,,");
		//calculate xor checksum in hex for nmea[0] until nmea[m]='*'(42)
		nmeachk = nmea[0];
		m = 1;
		while (nmea[m] != 42) {	//!="*"
			nmeachk = nmeachk ^ nmea[m];
			m++;
		}
		// convert calculated checksum to 2 digit hex there are 00 as base
		// so if only 1 digit put it to later position to get 0-header 01,02...
		nchk[0] = 0;
		nchk[1] = 0;
		snprintf(nchk, 3, "%X", nmeachk);
		if (nchk[1] == 0) {
			nmea[k + 4] = nchk[0];
		} else {
			nmea[k + 3] = nchk[0];
			nmea[k + 4] = nchk[1];
		}
		//In final. Add header "!" and trailer <cr><lf>
		// here it could be sent to /dev/ttySx
		DBG(printf("NMEA-message where it's made:  %s\n",nmea);)
		DBG(printf("NMEA: End of nmea->ascii-loop with sentences:%d sentencenum:%d\n",
			sentences, sentencenum));
	} while (sentencenum < sentences);
	return k+5;
}


int ais_ais_nmea::received ()  // Returns number of successfully received frames
{
	return d_receivedframes;
}

int ais_ais_nmea::lost()     // Returns number of frames with wrong checksum
{
	return d_lostframes;
}

int ais_ais_nmea::lost2()   // Returns number of frames with wrong start symbol or stop symbol
{
	return d_lostframes2;
}
void ais_ais_nmea::restart ()      // Called every time a frame has been finished received
{

  d_state = ST_SKURR;
  d_nskurr = 0;
  d_ndata = 0;
  d_npreamble = 0;
  d_nstartsign = 0;
  d_nstopsign = 0;
  d_antallpreamble = 0;
  d_antallenner = 0;
  d_last = 0;
  d_bitstuff = false;
  d_bufferpos = 0;
	DBG(printf("Resets\n");)
}

ais_ais_nmea::~ais_ais_nmea ()
{
}

int 
ais_ais_nmea::general_work (int noutput_items,
			gr_vector_int &ninput_items,
			gr_vector_const_void_star &input_items,
			gr_vector_void_star &output_items)
{
  const char *in = (char *) input_items[0];
  char *out;
  if (noutput_items != 0)
	out = (char *) output_items[0];
	//enum state_t { ST_SKURR, ST_PREAMBLE, ST_STARTSIGN, ST_DATA, ST_STOPSIGN};
	//int d_nskurr, d_npreamble, d_nstartsign, d_ndata,  d_nstopsign;
  int outnumber = 0;
  int i = 0;
  while (i < ninput_items[0]){
  switch(d_state)
  {
	case ST_DATA:
			if (d_bitstuff)
			{
				if(in[i] == 1)
				{	
					d_state = ST_STOPSIGN;
					d_ndata = 0;
					DBG(printf("%d",in[i]);)
					d_bitstuff = false;
					
				}
				else
				{
					d_ndata++;
					d_last = in[i];
					d_bitstuff = false;
				}	
			}
			else  {
				if(in[i] == d_last && in[i] == 1)
				{	d_antallenner++;
					if(d_antallenner == 4)
					{	d_bitstuff = true;	
						d_antallenner = 0;
					}

				}
				else
					d_antallenner = 0;
				
				DBG(printf("%d",in[i]);)
				d_buffer[d_bufferpos] = in[i]; 
				d_bufferpos++;
				d_ndata++;
				if (d_bufferpos >= 449) {
					restart();
				}
			}
		break;
	
	case ST_SKURR:                // The state when no reasonable input is coming
			if (in[i] != d_last)
				d_antallpreamble++;
			else
				d_antallpreamble = 0;
			d_last = in[i];
			if (d_antallpreamble > 14 && in[i] == 0)
			{
				d_state = ST_PREAMBLE;
			        d_nskurr = 0;	
				d_antallpreamble = 0;
				DBG(printf("Preamble\n");)
			}
			d_nskurr++;
		break;

	case ST_PREAMBLE:             // Switches to this state when preamble has been discovered
			DBG(printf("..%d..",in[i]);)
			if (in[i] != d_last && d_nstartsign == 0)
				d_antallpreamble++;
			else
			{
				if(in[i] == 1)    //To ettal har kommet etter hverandre 
				{
					if(d_nstartsign == 0){    // Forste gang det skjer
						d_nstartsign = 3;
						d_last = in[i];
					}
					else if (d_nstartsign == 5)   // Har oppdaget start av startsymbol
					{
						d_nstartsign++;
						d_npreamble = 0;
						d_antallpreamble = 0;
						d_state = ST_STARTSIGN;
					}
					else{
						d_nstartsign++;
					}
						
				}
				else   //To nuller har kommet etter hverandre
				{
					if(d_nstartsign == 0)
					{	d_nstartsign =1;
						
					}	
					else
					{
						restart();
					}
				}
			}
			d_npreamble++;
		break;
	
	case ST_STARTSIGN:                 
			//printf("..%d..",in[i]);
			//printf("Startsign: %d\n",d_nstartsign);
			if(d_nstartsign >=7)
			{
				if (in[i] == 0)
				{
					DBG(printf("\nData:\n");)
					d_state = ST_DATA;
					d_nstartsign = 0;
					d_antallenner = 0;
					memset(d_buffer,0,250*sizeof(char));
					d_bufferpos = 0;
				}
				else {
					restart();
				}
				
			}
			else if (in[i] == 0)
			{
				restart();
			}
			d_nstartsign++;
		break;
	
	case ST_STOPSIGN:
		int bufferlengde = d_bufferpos - 6 -16;
		if(in[i] == 0 && bufferlengde > 0)
		{
			DBG(printf("%d\n\nFrame received OK.  %d bits\n",in[i],bufferlengde);)
			bool correct = calculate_crc(bufferlengde);
			if(correct)
			{
				DBG(printf("CRC Checksum correct! Frame Successfully Received!!!\n");)
				d_receivedframes++;
				d_tbuffer = (char*) malloc((bufferlengde+1)*sizeof(char));
				if (d_tbuffer == NULL)
				{
					throw std::runtime_error("Error allocating memory\n");
				}
				char nmea[NMEA_LENGTH];
				int nmealength = protodec_generate_nmea(nmea,bufferlengde,0);
				if (noutput_items != 0) {
					memcpy(out,nmea,NMEA_LENGTH);
					out += NMEA_LENGTH;
					outnumber++;	
				}
				//gr_message_sptr msg = gr_make_message(0,0,0,nmealength);
				//memcpy(msg->msg(), nmea,nmealength);
				//d_nmea_queue->insert_tail(msg);
				//msg.reset();
				//get_data(bufferlengde);
				DBG(printf("   (%s)\n",nmea);)
				free(d_tbuffer);
		/*		printf("\n<--");
				for(int l=0;l<bufferlengde;l++)
				{
					printf("%c",d_rbuffer[l]+0x30);
				}
				printf("-->\n");*/
			}
			else{
				DBG(printf("CRC Checksum FALSE!!!\n");)
				d_lostframes++;
			}
			DBG(printf("_________________________________________________________\n\n");)
			
		}
		else{
			DBG(printf("\n\nERROR in Frame\n__________________________________________________________\n\n");)
			d_lostframes2++;
		}
		restart();
		break;


  }
			d_last = in[i];
  			i++;
  }


  consume_each(ninput_items[0]);
  return outnumber;

}
